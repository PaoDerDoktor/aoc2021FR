# --- Jour 20 : Carte de la Fosse ---

Une fois les senseurs complètement déployés, vous recentrez votre attention sur la cartographie du plancher océanique de la fosse.

Quand vous récupérez l'image depuis les senseurs, il semble qu'elle ne soit que du bruit aléatoire. Peut-être que vous pouvez combiner un algorithme d'amélioration d'image et l'image d'entrée (l'entrée de votre puzzle) pour nettoyer un peu tout ça.

Par exemple :

```floorMapInput
..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..##
#..######.###...####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###
.######.###.####...#.##.##..#..#..#####.....#.#....###..#.##......#.....#.
.#..#..##..#...##.######.####.####.#.#...#.......#..#.#.#...####.##.#.....
.#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.###.##...#..
...####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.....
..##..####..#...#.#.#...##..#.#..###..#####........#..####......#..#

#..#.
#....
##..#
..#..
..###
```

La première section de cette entrée est *l'algorithme d'amélioration d'image*. Il est normalement donné sur une seule ligne, mais a ici été étalé sur plusieurs lignes pour la lisibilité. La seconde section est *l'image en entrée*, une grille en deux dimensions de *pixels clairs* (`#`) et de *pixels sombres* (`.`).

L'algorithme d'amélioration d'image décrit comment améliorer une image en convertissant *simultanément* tous les pixels de l'image en entrée en image en sortie. Chaque pixel de l'image en sortie est déterminé en regardant un carré de 3x3 pixels centré sur le pixel correspondant de l'image en entrée. Donc, pour déterminer la valeur du pixel en (5,10) dans l'image en sortie, neuf pixels de l'image en entrée sont à traiter : (4,9), (4,10), (4,11), (5,9), (5,10), (5,11), (6,9), (6,10) et (6,11). Ces neuf pixels en entrée sont combinés en un seul nombre binaire, utilisé ensuite en tant qu'index dans la chaîne de l'a*algorithme d'amélioration d'image*.

Par exemple, pour déterminer le pixel en sortie correspondant au pixel pile au milieu de l'image en entrée, les neufs pixels marqués par ``[...]`` doivent être traités :

```floorMapMarked
# . . # .
#[. . .].
#[# . .]#
.[. # .].
. . # # #
```

En démarrant du coin supérieur-gauche et en lisant toutes les lignes, ces pixels sont ``...``, puis ``#..`` et enfin ``.#.``, soit une fois combinés ``...#...#.``. En transformant les pixels sombres (`.`) en `0` et les pixels clairs (`#`) en `1`, le nombre binaire `000100010` peut être formé, soit `34` en décimal.

L'algorithme d'amélioration d'image est une chaîne d'exactement 512 caractères de long, assez pour correspondre à tout nombre binaire de 9 bits. Les quelques premiers caractères de la chaîne (numérotés à partir de zéro) sont ainsi :

```enhanceAlgorithmStringAnnotated
0         10        20        30  34    40        50        60        70
|         |         |         |   |     |         |         |         |
..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..##
```

Au milieu u premier groupe dde caractères, le caractère à l'index 34 peut être trouvé : `#`. Ainsi, le pixel en sortie du centre de l'image en sortie devrait être `#`, un *pixel clair*.

Le processus peut ensuite être répété pour calculer chaque pixel de l'image en sortie.

Grâce à des avancées en technologies d'imagerie, les images traitées ici sont *infinies* en taille. *Chaque* pixel de l'image en sortie infinie doit être calculé exactement en se basant sur les pixels de l'image en entrée correspondants. La petite image en entrée que vous avez obtenu n'est qu'une petite région d'une image en réalité infinie ; le reste de l'image contient des pixels sombres (`.`). Pour l'intérêt de cet exemple, pour garder de la place, seule une portion des images infinies en entrées et en sorties seront montrées.

L'image en entrée de départ, du coup, ressemble à ceci, avec plus de pixels sombres (`.`) s'étendant à jamais dans toutes les directions non-montrées ici :

```floorMap
...............
...............
...............
...............
...............
.....#..#......
.....#.........
.....##..#.....
.......#.......
.......###.....
...............
...............
...............
...............
...............
```

En appliquant l'algorithme d'amélioration d'image à chaque pixel simultanément, l'image en sortie suivante peut être obtenue :

```floorMap
...............
...............
...............
...............
.....##.##.....
....#..#.#.....
....##.#..#....
....####..#....
.....#..##.....
......##..#....
.......#.#.....
...............
...............
...............
...............
```

Grâce à d'autres avancées en technologies d'imagerie, l'image en sortie ci-dessus peut également être utilisée en tant qu'image en entrée ! Ceci permet à l'image d'être améliorée *une seconde fois* :

```floorMap
...............
...............
...............
..........#....
....#..#.#.....
...#.#...###...
...#...##.#....
...#.....#.#...
....#.#####....
.....#.#####...
......##.##....
.......###.....
...............
...............
...............
```

Vraiment incroyable ; maintenant, chaque petit détail commence vraiment à s'apercevoir. Après avoir amélioré l'image originale deux fois, *`35`* pixels sont clairs.

Commencez avec l'image en entrée originale et appliquez l'algorithme d'amélioration d'image deux fois, en faisant attention au caractère infini de la taille des images. *Combien de pixels sont clairs dans l'image résultante ?*
